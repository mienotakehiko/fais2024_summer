maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.
theory CPA_symmetrickey_20240705_notoutkey begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, sdec/2, senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2



heuristic: o "myoracle"



rule (modulo E) Setup:
   [ Fr( ~key ) ] --[ OnlyOnce( ), Setup( ~key ) ]-> [ !Skey( $A, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) attackerkey:
   [ !Skey( $A, key ) ] --[ Attacker( $A ) ]-> [ Out( key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker_make_message:
   [ Fr( m_ ) ] --> [ Out( <$A, m_> ), St_Attacker( m_ ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Encrypt_oracle:
   [ In( <$A, m_> ), Fr( ~key ), St_Attacker( m_ ) ]
  --[
  Send( $A, senc(<$A, m_>, ~key) ), Secret( m_ ), Oracle( $A ),
  Sender( $B ), Role( 'Oracle' ), Oracle_send_plain( m_ )
  ]->
   [ Out( senc(<$A, m_>, ~key) ), St_ReceiveKeyOracleplain( m_, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender_encrypt:
   [ Fr( ~m ), Fr( ~key ) ]
  --[
  Send( $B, senc(<$B, ~m>, ~key) ), Secret( ~m ), Sender( $B ),
  Oracle( $A ), Role( 'Sender' ), Sender_send_plain( ~m )
  ]->
   [ Out( senc(<$B, ~m>, ~key) ), St_ReceiveKey( ~m, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker:
   [
   St_ReceiveKeyOracleplain( m_, key_ ), In( senc(<$A, m_>, key_) ),
   St_ReceiveKey( ~m, key ), In( senc(<$B, ~m>, key) )
   ]
  --[
  Notequalvalue( <senc(m_, key_), senc(~m, key)> ),
  Secretmessage( sdec(senc(m_, key_), key) )
  ]->
   [ ]

  /*
  rule (modulo AC) Attacker:
     [
     St_ReceiveKeyOracleplain( m_, key_ ), In( senc(<$A, m_>, key_) ),
     St_ReceiveKey( ~m, key ), In( senc(<$B, ~m>, key) )
     ]
    --[ Notequalvalue( <senc(m_, key_), senc(~m, key)> ), Secretmessage( z )
    ]->
     [ ]
    variants (modulo AC)
    1. key   = key.8
       key_  = key_.8
       m_    = m_.8
       z     = sdec(senc(m_.8, key_.8), key.8)
    
    2. key   = x.8
       key_  = x.8
       m_    = m_.9
       z     = m_.9
  */

restriction OnlyOnce:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction choiceplain:
  "∀ x #i.
    (Oracle_send_plain( x ) @ #i) ⇒
    ((∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ (#j < #i)) ∨
     (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ (#j < #i)))"

lemma value_notequal:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
simplify
solve( St_ReceiveKeyOracleplain( m_, key_ ) ▶₀ #i )
  case Encrypt_oracle
  solve( St_ReceiveKey( ~m, key.1 ) ▶₂ #i )
    case Sender_encrypt
    solve( St_ReceiveKeyOracleplain( ~n, ~key ) ▶₀ #j )
      case Encrypt_oracle
      by contradiction /* from formulas */
    qed
  qed
qed

lemma secret_sender_message:
  all-traces
  "∀ n #i.
    ((Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)) ⇒
    ((¬(∃ #j. K( n ) @ #j)) ∨
     (∃ B #j. (Attacker( B ) @ #j) ∧ (Sender( B ) @ #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ n #i.
  (Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)
 ∧
  (∃ #j. (K( n ) @ #j)) ∧
  (∀ B #j. (Attacker( B ) @ #j) ∧ (Sender( B ) @ #i) ⇒ ⊥)"
*/
simplify
solve( Secret( n ) @ #i )
  case Encrypt_oracle
  by solve( Role( 'Sender' ) @ #i )
next
  case Sender_encrypt
  solve( Role( 'Sender' ) @ #i )
    case Sender_encrypt
    solve( !KU( ~m ) @ #vk )
      case Sender_encrypt
      by solve( !KU( ~key ) @ #vk.1 )
    qed
  qed
qed

lemma m_secret:
  all-traces "∀ m #i. (Secretmessage( m ) @ #i) ⇒ (¬(∃ #j. K( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m #i. (Secretmessage( m ) @ #i) ∧ ∃ #j. (K( m ) @ #j)"
*/
simplify
solve( splitEqs(0) )
  case split_case_1
  solve( St_ReceiveKeyOracleplain( m_, key_ ) ▶₀ #i )
    case Encrypt_oracle
    solve( !KU( senc(<$A, ~n>, ~key) ) @ #vk )
      case Encrypt_oracle
      solve( St_ReceiveKey( ~m, key.1 ) ▶₂ #i )
        case Sender_encrypt
        solve( !KU( senc(<$B, ~m>, ~key.1) ) @ #vk.1 )
          case Sender_encrypt
          solve( !KU( sdec(senc(~n, ~key), ~key.1) ) @ #vk.2 )
            case c_sdec
            solve( !KU( ~n ) @ #vk.5 )
              case Attacker_make_message
              solve( (∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ #j < #vr)  ∥
                     (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ #j < #vr) )
                case case_1
                solve( !KU( senc(~n, ~key) ) @ #vk.6 )
                  case c_senc
                  by solve( !KU( ~key.1 ) @ #vk.7 )
                qed
              next
                case case_2
                solve( !KU( senc(~n, ~key) ) @ #vk.6 )
                  case c_senc
                  by solve( !KU( ~key.1 ) @ #vk.7 )
                qed
              qed
            qed
          qed
        next
          case c_senc
          solve( !KU( sdec(senc(~n, ~key), ~key.1) ) @ #vk.2 )
            case c_sdec
            solve( !KU( ~n ) @ #vk.5 )
              case Attacker_make_message
              solve( (∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ #j < #vr)  ∥
                     (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ #j < #vr) )
                case case_1
                by solve( !KU( ~key.1 ) @ #vk.7 )
              next
                case case_2
                by solve( !KU( ~key.1 ) @ #vk.7 )
              qed
            qed
          qed
        qed
      qed
    next
      case c_senc
      solve( St_ReceiveKey( ~m, key.1 ) ▶₂ #i )
        case Sender_encrypt
        solve( !KU( senc(<$B, ~m>, ~key.1) ) @ #vk.1 )
          case Sender_encrypt
          solve( !KU( sdec(senc(~n, ~key), ~key.1) ) @ #vk.2 )
            case c_sdec
            solve( !KU( ~n ) @ #vk.5 )
              case Attacker_make_message
              solve( (∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ #j < #vr)  ∥
                     (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ #j < #vr) )
                case case_1
                by solve( !KU( ~key ) @ #vk.7 )
              next
                case case_2
                by solve( !KU( ~key ) @ #vk.7 )
              qed
            qed
          qed
        next
          case c_senc
          solve( !KU( sdec(senc(~n, ~key), ~key.1) ) @ #vk.2 )
            case c_sdec
            solve( !KU( ~n ) @ #vk.5 )
              case Attacker_make_message
              solve( (∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ #j < #vr)  ∥
                     (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ #j < #vr) )
                case case_1
                by solve( !KU( ~key ) @ #vk.7 )
              next
                case case_2
                by solve( !KU( ~key ) @ #vk.7 )
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case split_case_2
  solve( St_ReceiveKeyOracleplain( m_, key ) ▶₀ #i )
    case Encrypt_oracle
    solve( !KU( senc(<$A, ~n>, ~key) ) @ #vk )
      case Encrypt_oracle
      by solve( St_ReceiveKey( ~m, ~key ) ▶₂ #i )
    next
      case c_senc
      by solve( St_ReceiveKey( ~m, ~key ) ▶₂ #i )
    qed
  qed
qed











/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2023-08-30 19:02:12.455846 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: cpamodel_verification_symmetric-encryption.spthy

  processing time: 2.69s
  
  value_notequal (all-traces): verified (5 steps)
  secret_sender_message (all-traces): verified (6 steps)
  m_secret (all-traces): verified (34 steps)

==============================================================================
