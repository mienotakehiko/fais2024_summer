maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.
theory CPA_symmetrickey_oracleuse_notoutkey begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, sdec/2, senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2



heuristic: o "myoracle"



rule (modulo E) Setup:
   [ Fr( ~key ) ] --[ OnlyOnce( ), Setup( ~key ) ]-> [ !Skey( $A, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) attackerkey:
   [ !Skey( $A, key ) ] --[ Attacker( $A ) ]-> [ Out( key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker_make_message:
   [ Fr( m_ ) ] --> [ Out( <$A, m_> ), St_Attacker( m_ ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Encrypt_oracle:
   [ In( <$A, m_> ), Fr( ~key ), St_Attacker( m_ ) ]
  --[
  Send( $A, senc(<$A, m_>, ~key) ), Secret( m_ ), Oracle( $A ),
  Sender( $B ), Role( 'Oracle' ), Oracle_send_plain( m_ )
  ]->
   [ Out( senc(<$A, m_>, ~key) ), St_ReceiveKeyOracleplain( m_, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender_encrypt:
   [ Fr( ~m ), Fr( ~key ) ]
  --[
  Send( $B, senc(<$B, ~m>, ~key) ), Secret( ~m ), Sender( $B ),
  Oracle( $A ), Role( 'Sender' ), Sender_send_plain( ~m )
  ]->
   [ Out( <senc(<$B, ~m>, ~key), ~key> ), St_ReceiveKey( ~m, ~key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker:
   [
   St_ReceiveKeyOracleplain( m_, key_ ), In( senc(<$A, m_>, key_) ),
   St_ReceiveKey( ~m, key ), In( senc(<$B, ~m>, key) )
   ]
  --[
  Notequalvalue( <senc(m_, key_), senc(~m, key)> ),
  Secretmessage( sdec(senc(~m, key), key) )
  ]->
   [ ]

  /*
  rule (modulo AC) Attacker:
     [
     St_ReceiveKeyOracleplain( m_, key_ ), In( senc(<$A, m_>, key_) ),
     St_ReceiveKey( ~m, key ), In( senc(<$B, ~m>, key) )
     ]
    --[ Notequalvalue( <senc(m_, key_), senc(~m, key)> ), Secretmessage( ~m )
    ]->
     [ ]
  */

restriction OnlyOnce:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction choiceplain:
  "∀ x #i.
    (Oracle_send_plain( x ) @ #i) ⇒
    ((∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ (#j < #i)) ∨
     (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ (#j < #i)))"

lemma value_notequal:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
simplify
solve( St_ReceiveKeyOracleplain( m_, key_ ) ▶₀ #i )
  case Encrypt_oracle
  solve( St_ReceiveKey( ~m, key.1 ) ▶₂ #i )
    case Sender_encrypt
    solve( St_ReceiveKeyOracleplain( ~n, ~key ) ▶₀ #j )
      case Encrypt_oracle
      by contradiction /* from formulas */
    qed
  qed
qed

lemma secret_sender_message:
  all-traces
  "∀ n #i.
    ((Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)) ⇒
    ((¬(∃ #j. K( n ) @ #j)) ∨
     (∃ B #j. (Attacker( B ) @ #j) ∧ (Sender( B ) @ #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ n #i.
  (Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)
 ∧
  (∃ #j. (K( n ) @ #j)) ∧
  (∀ B #j. (Attacker( B ) @ #j) ∧ (Sender( B ) @ #i) ⇒ ⊥)"
*/
simplify
solve( Secret( n ) @ #i )
  case Sender_encrypt
  solve( Role( 'Sender' ) @ #i )
    case Sender_encrypt
    solve( !KU( ~m ) @ #vk )
      case Sender_encrypt
      solve( !KU( ~key ) @ #vk.1 )
        case Sender_encrypt
        SOLVED // trace found
      qed
    qed
  qed
qed

lemma m_secret:
  all-traces "∀ m #i. (Secretmessage( m ) @ #i) ⇒ (¬(∃ #j. K( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m #i. (Secretmessage( m ) @ #i) ∧ ∃ #j. (K( m ) @ #j)"
*/
simplify
solve( St_ReceiveKeyOracleplain( m_, key_ ) ▶₀ #i )
  case Encrypt_oracle
  solve( !KU( senc(<$A, ~n>, ~key) ) @ #vk )
    case Encrypt_oracle
    solve( St_ReceiveKey( ~m, key.1 ) ▶₂ #i )
      case Sender_encrypt
      solve( !KU( senc(<$B, ~m>, ~key.1) ) @ #vk.1 )
        case Sender_encrypt
        solve( !KU( ~m ) @ #vk.2 )
          case Sender_encrypt
          solve( !KU( ~n ) @ #vk.5 )
            case Attacker_make_message
            solve( (∃ y #j. (Oracle_send_plain( y ) @ #j) ∧ #j < #vr)  ∥
                   (∃ y #j. (Sender_send_plain( y ) @ #j) ∧ #j < #vr) )
              case case_1
              solve( !KU( ~key.1 ) @ #vk.6 )
                case Sender_encrypt
                solve( St_Attacker( y ) ▶₂ #j.1 )
                  case Attacker_make_message
                  solve( (∃ y #j.2. (Oracle_send_plain( y ) @ #j.2) ∧ #j.2 < #j.1)  ∥
                         (∃ y #j.2. (Sender_send_plain( y ) @ #j.2) ∧ #j.2 < #j.1) )
                    case case_1
                    solve( !KU( ~n.1 ) @ #vk.9 )
                      case Attacker_make_message
                      solve( St_Attacker( y ) ▶₂ #j.2 )
                        case Attacker_make_message
                        solve( (∃ y #j.3. (Oracle_send_plain( y ) @ #j.3) ∧ #j.3 < #j.2)  ∥
                               (∃ y #j.3. (Sender_send_plain( y ) @ #j.3) ∧ #j.3 < #j.2) )
                          case case_2
                          solve( !KU( ~n.2 ) @ #vk.12 )
                            case Attacker_make_message
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed











/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2023-08-30 19:02:12.455846 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: cpamodel_verification_symmetric-encryption_out.spthy

  processing time: 2.74s
  
  value_notequal (all-traces): verified (5 steps)
  secret_sender_message (all-traces): falsified - found trace (6 steps)
  m_secret (all-traces): falsified - found trace (16 steps)

==============================================================================
